<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  html, body { margin:0; background:transparent; overflow:hidden; }
  * { box-sizing:border-box; }

  :root{
    --bottom: 120px;

    --heart-h: 260px;
    --heart-scale: 1;

    --title-size: 56px;
    --name-size: 46px;

    /* ✅ requested timing */
    --fade-ms: 1000ms;          /* 1s fade */
    --idle-ms: 6000ms;          /* 6s fully visible (idle) */

    --carpet-w: 860px;
    --carpet-h: 110px;
    --carpet-radius: 26px;

    --pad-left: 28px;
    --title-offset: 50px;

    --overlap: 20px;            /* heart overlaps carpet a bit */
    --heart-w: 220px;           /* stable width used for layout calc */
  }

  @font-face{
    font-family: "OverlayFont";
    src: url("./images/Poppins-BlackItalic.ttf") format("truetype");
    font-weight: 900;
    font-style: italic;
    font-display: swap;
  }

  #wrap{
    position: fixed;
    left:0; right:0;
    bottom: var(--bottom);
    display:flex;
    justify-content:center;
    pointer-events:none;
  }

  #frame{
    position: relative;
    width: min(1080px, 100vw);
    height: max(var(--heart-h), var(--carpet-h));
  }

  #title{
    position: absolute;
    left: 0;
    top: 0;
    transform: translate3d(0, calc(-1 * var(--title-offset)), 0);

    font-family: "OverlayFont","Segoe UI",Arial,sans-serif;
    font-weight: 900;
    font-style: italic;
    font-size: var(--title-size);
    letter-spacing: 3px;
    text-transform: uppercase;
    color: #D4AF37;
    white-space: nowrap;
    z-index: 3;
  }

  #stage{
    position:absolute;
    left:0; top:0;
    width:100%;
    height:100%;
  }

  #card{
    position:absolute;
    left:0;
    top:50%;
    transform: translate3d(0,-50%,0);
    width: 100%;
    height: 100%;
  }

  /* each layer fills the card and crossfades */
  .layer{
    position:absolute;
    inset:0;
    opacity:0;
    transition: opacity var(--fade-ms) linear;
    will-change: opacity;
  }
  .layer.on{ opacity:1; }

  /* optional tiny "pop" (still cheap: transform) */
  .layer.on .name,
  .layer.on .heartWrap{
    animation: popIn var(--fade-ms) ease-out both;
    will-change: transform, opacity;
  }

  @keyframes popIn{
    from { transform: translate3d(0,-50%,0) scale(0.985); opacity: 0.9; }
    to   { transform: translate3d(0,-50%,0) scale(1); opacity: 1; }
  }

  /* carpet */
  .carpet{
    position:absolute;
    left:0;
    top:50%;
    transform: translate3d(0,-50%,0);
    width: var(--carpet-w);
    height: var(--carpet-h);
    border-radius: var(--carpet-radius);
    overflow:hidden;

    background: linear-gradient(
      180deg,
      rgba(255, 40, 40, 0.95) 0%,
      rgba(220, 0, 0, 0.95) 45%,
      rgba(140, 0, 0, 0.95) 100%
    );

    /* reduced cost shadow */
    box-shadow:
      0 0 12px rgba(255, 0, 0, 0.45),
      0 0 22px rgba(255, 0, 0, 0.28);
  }

  /* name */
  .name{
    position:absolute;
    left: var(--pad-left);
    top:50%;
    transform: translate3d(0,-50%,0);

    font-family: "OverlayFont","Segoe UI",Arial,sans-serif;
    font-weight: 900;
    font-style: italic;
    font-size: var(--name-size);
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #D4AF37;

    white-space: nowrap;
    z-index: 2;
  }

  /* heart placement */
  .heartWrap{
    position:absolute;
    left: calc(var(--carpet-w) - var(--overlap));
    top:50%;
    transform: translate3d(0,-50%,0);
    z-index: 2;
  }

  /* ✅ requested: PNG itself fades too */
  .heart{
    height: calc(var(--heart-h) * var(--heart-scale));
    width: auto;
    display:block;

    opacity: 0;
    transition: opacity var(--fade-ms) linear;
    will-change: opacity;
  }
  .layer.on .heart{
    opacity: 1;
  }

  /* measure text width offscreen */
  #measure{
    position:absolute;
    left:-99999px;
    top:-99999px;
    visibility:hidden;
    white-space:nowrap;
    font-size: var(--name-size);
    font-family: "OverlayFont","Segoe UI",Arial,sans-serif;
    font-weight: 900;
    font-style: italic;
    letter-spacing: 2px;
    text-transform: uppercase;
  }
</style>
</head>

<body>
  <div id="wrap">
    <div id="frame">
      <div id="title">TOP MEMBERS</div>

      <div id="stage">
        <div id="card">

          <!-- Layer A -->
          <div id="layerA" class="layer on">
            <div class="carpet"></div>
            <div id="nameA" class="name">POPEVA - 46</div>
            <div class="heartWrap">
              <img id="heartA" class="heart" src="images/top.png" alt="">
            </div>
          </div>

          <!-- Layer B -->
          <div id="layerB" class="layer">
            <div class="carpet"></div>
            <div id="nameB" class="name">SALVIOR - 37</div>
            <div class="heartWrap">
              <img id="heartB" class="heart" src="images/mid.png" alt="">
            </div>
          </div>

        </div>
      </div>

    </div>
  </div>

  <div id="measure"></div>

<script>
  // timing (ms)
  const FADE_MS = 1000;  // 1s
  const IDLE_MS = 6000;  // 6s fully visible after fade
  const PAGE_MS = FADE_MS + IDLE_MS; // total per item

  const pages = [
    { img: "images/top.png", text: "POPEVA - 46" },
    { img: "images/mid.png", text: "SALVIOR - 37" },
    { img: "images/mid.png", text: "GHOST RIDER - 34" },
    { img: "images/mid.png", text: "LINIQ - 30" },
    { img: "images/low.png", text: "VLADI13_12 - 29" },
    { img: "images/low.png", text: "OBERON - 28" }
  ];

  const frame  = document.getElementById("frame");
  const meas   = document.getElementById("measure");

  const layerA = document.getElementById("layerA");
  const layerB = document.getElementById("layerB");

  const nameA  = document.getElementById("nameA");
  const nameB  = document.getElementById("nameB");

  const heartA = document.getElementById("heartA");
  const heartB = document.getElementById("heartB");

  const rootStyle = document.documentElement.style;

  let idx = 0;
  let showingA = true;
  let fontsReady = false;

  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

  async function ensureFontsOnce(){
    if (fontsReady) return;
    if (document.fonts?.ready) {
      try { await document.fonts.ready; } catch(e){}
    }
    fontsReady = true;
  }

  async function preloadImages(){
    const uniq = [...new Set(pages.map(p => p.img))];
    await Promise.all(uniq.map(src => {
      const img = new Image();
      img.src = src;
      return img.decode ? img.decode().catch(()=>{}) : Promise.resolve();
    }));
  }

  function setScaleFor(src){
    rootStyle.setProperty(
      "--heart-scale",
      (src.includes("mid.png") || src.includes("low.png")) ? "0.6" : "1"
    );
  }

  function computeCarpetW(text){
    // simple + cheap: measure text only
    const afterTextPx = 50;
    const padLeft = 28;

    meas.textContent = text;
    const textW = meas.offsetWidth;

    // stable heart width avoids layout reads (tune if needed)
    const heartW = 220;
    const overlapPx = 20;

    const frameW = frame.offsetWidth;

    let carpetW = padLeft + textW + afterTextPx;
    const maxCarpetW = Math.max(240, frameW - heartW + overlapPx);
    carpetW = clamp(carpetW, 240, maxCarpetW);

    rootStyle.setProperty("--carpet-w", carpetW + "px");
  }

  function setLayerContent(isA, p){
    if (isA){
      nameA.textContent = p.text;
      heartA.src = p.img;
    } else {
      nameB.textContent = p.text;
      heartB.src = p.img;
    }
  }

  async function show(p){
    await ensureFontsOnce();

    // Update layout + scale based on the incoming item
    setScaleFor(p.img);
    computeCarpetW(p.text);

    // Fill the hidden layer with next content BEFORE fading
    const nextIsA = !showingA;
    setLayerContent(nextIsA, p);

    // Ensure the new image is decoded (preload already helps, but this avoids rare hiccups)
    const imgEl = nextIsA ? heartA : heartB;
    if (imgEl.decode) { try { await imgEl.decode(); } catch(e){} }

    // Crossfade layers
    requestAnimationFrame(() => {
      if (nextIsA){
        layerA.classList.add("on");
        layerB.classList.remove("on");
      } else {
        layerB.classList.add("on");
        layerA.classList.remove("on");
      }
      showingA = nextIsA;
    });

    // Wait total duration (fade + idle)
    await sleep(PAGE_MS);
  }

  window.addEventListener("resize", () => {
    const current = pages[(idx - 1 + pages.length) % pages.length];
    computeCarpetW(current.text);
  }, { passive:true });

  (async function init(){
    await preloadImages();

    // initial content
    await ensureFontsOnce();
    setLayerContent(true, pages[0]);
    setScaleFor(pages[0].img);
    computeCarpetW(pages[0].text);

    // make sure first PNG is visible
    layerA.classList.add("on");
    layerB.classList.remove("on");
    showingA = true;

    idx = 1;

    while(true){
      await show(pages[idx]);
      idx = (idx + 1) % pages.length;
    }
  })();
</script>
</body>
</html>
